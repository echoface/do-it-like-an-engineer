# lambda è¡¨è¾¾å¼çš„ç§˜å¯†ä¸é™·é˜±

ç®€å•ç¤ºä¾‹:
---

```c++
#include <algorithm>
#include <cmath>
void abssort(float* x, unsigned n) {
    std::sort(x, x + n,
        // Lambda expression begins
        [](float a, float b) {
            return (std::abs(a) < std::abs(b));
        } // end of lambda expression
    );

}
```
å®šä¹‰:
---

ç›—å–çš„å¾®è½¯çš„å›¾ğŸ”«
![lambdaå›¾ç¤º](/MacIOS_development/img/IC251606.jpeg)

1. Capture å­å¥ï¼ˆåœ¨ C++ è§„èŒƒä¸­ä¹Ÿç§°ä¸º lambda å¼•å¯¼ã€‚ï¼‰
2. å‚æ•°åˆ—è¡¨ï¼ˆå¯é€‰ï¼‰ã€‚ ï¼ˆä¹Ÿç§°ä¸º lambda å£°æ˜ç¬¦)
3. å¯å˜è§„èŒƒï¼ˆå¯é€‰ï¼‰ã€‚
4. å¼‚å¸¸è§„èŒƒï¼ˆå¯é€‰ï¼‰ã€‚
5. å°¾éšè¿”å›ç±»å‹ï¼ˆå¯é€‰ï¼‰ã€‚
6. â€œlambda ä½“â€

Lambda å¯åœ¨å…¶ä¸»ä½“ä¸­å¼•å…¥æ–°çš„å˜é‡ï¼ˆç”¨ C++14ï¼‰ï¼Œå®ƒè¿˜å¯ä»¥è®¿é—®ï¼ˆæˆ–â€œæ•è·â€ï¼‰ä¸Šä¸‹æ–‡èŒƒå›´å†…çš„å˜é‡ã€‚ Lambda è¡¨è¾¾å¼ä»¥ Capture å­å¥ï¼ˆä¹Ÿå°±æ˜¯`[]`ï¼‰å¼€å¤´ï¼Œå®ƒæŒ‡å®šè¦æ•è·çš„å˜é‡ä»¥åŠæ˜¯é€šè¿‡å€¼è¿˜æ˜¯å¼•ç”¨è¿›è¡Œæ•è·ã€‚ æœ‰ä¸å· `(&)` å‰ç¼€çš„å˜é‡é€šè¿‡å¼•ç”¨è®¿é—®ï¼Œæ²¡æœ‰è¯¥å‰ç¼€çš„å˜é‡é€šè¿‡å€¼è®¿é—®ã€‚ç©º capture å­å¥ `[ ]` æŒ‡ç¤º lambda è¡¨è¾¾å¼çš„ä¸»ä½“ä¸è®¿é—®å°é—­èŒƒå›´ä¸­çš„å˜é‡ã€‚

å¯ä»¥ä½¿ç”¨é»˜è®¤æ•è·æ¨¡å¼ï¼ˆæ ‡å‡†è¯­æ³•ä¸­çš„ capture-defaultï¼‰æ¥æŒ‡ç¤ºå¦‚ä½•æ•è· lambda ä¸­å¼•ç”¨çš„ä»»ä½•å¤–éƒ¨å˜é‡ï¼š`[&]` è¡¨ç¤ºé€šè¿‡å¼•ç”¨æ•è·å¼•ç”¨çš„æ‰€æœ‰å˜é‡ï¼Œè€Œ `[=]` è¡¨ç¤ºé€šè¿‡å€¼æ•è·å®ƒä»¬ã€‚ å¯ä»¥ä½¿ç”¨é»˜è®¤æ•è·æ¨¡å¼ï¼Œç„¶åä¸ºç‰¹å®šå˜é‡æ˜¾å¼æŒ‡å®šç›¸åçš„æ¨¡å¼ã€‚ ä¾‹å¦‚ï¼Œå¦‚æœ lambda ä½“é€šè¿‡å¼•ç”¨è®¿é—®å¤–éƒ¨å˜é‡ total å¹¶é€šè¿‡å€¼è®¿é—®å¤–éƒ¨å˜é‡ factorï¼Œåˆ™ä»¥ä¸‹ capture å­å¥ç­‰æ•ˆï¼š

```c++
//ä¸‹é¢æ‰€æœ‰çš„å†™æ³•éƒ½è¡¨ç¤º å¯¹å˜é‡`factor`ä½¿ç”¨å€¼æ•è·ï¼Œ å¯¹`total`ä½¿ç”¨åº”ç”¨æ•è·
[&total, factor]
[factor, &total]
[&, factor]
[factor, &]
[=, &total]
[&total, =]
```

lambdaè¡¨è¾¾å¼çš„å®ç°
---
å‡½æ•°å¯¹è±¡ï¼›åˆ›é€ åŒ¿åç±»å¯¹è±¡ï¼Œé‡è½½`()`è¿ç®—ç¬¦ï¼›

åœ¨C++ä¸­ï¼Œ lambdaè¡¨è¾¾å¼ä¸æ˜¯C++11æ‰ç‰¹æœ‰çš„ï¼Œboostä¸­å°±æœ‰å®ƒè‡ªå·±çš„å®ç°ï¼›lambdaè¡¨è¾¾å¼å°±åƒæ‰€æœ‰å…¶ä»–c++å¯¹è±¡ä¸€æ ·å°±æ˜¯ä¸€ä¸ªå¯¹è±¡ï¼›åœ¨åˆå§‹åŒ–ä¸€ä¸ªlambdaè¡¨è¾¾å¼æ—¶ï¼Œå°±æ˜¯åœ¨stackä¸Šåˆ›å»ºçš„ä¸€ä¸ªä¸´æ—¶çš„åŒ¿åçš„å¯¹è±¡
åœ¨c++11çš„specä¸­ï¼š
> A Note About Function Pointers

>Under the final C++11 spec, if you have a lambda with an empty capture specification, then it can be treated like a regular function and assigned to a function pointer. Here's an example of using a function pointer with a capture-less lambda:

æ‰€ä»¥è¿™å¥è¯æ˜¯æˆç«‹çš„`auto lamb = []() {return 5;};` è¿™é‡Œçš„lambå°±æ˜¯stack objectï¼Œ å®ƒæœ‰ä¸€ä¸ªæ„é€ å‡½æ•°ä¹Ÿæœ‰ä¸€ä¸ªææ„å‡½æ•°ï¼å’Œä½ åˆ›å»ºçš„ç±»ä¸€æ ·ï¼›è€Œæ‰€è°“çš„capture listï¼ˆæ•è·åˆ—è¡¨ï¼‰å°±æ˜¯dambdaå¯¹è±¡çš„æˆå‘˜å˜é‡è€Œå·²ï¼›å› ä¸ºä»–æ˜¯ä¸ªå¯¹è±¡ï¼Œæ‰€ä»¥ä¸Šé¢åˆ›é€ çš„lambå¯¹è±¡ä¹Ÿå¯ä»¥èµ‹å€¼ç»™ std::function (å‡½æ•°å¯¹è±¡) `auto f_lamb = std::function<int()>(lamb)`; è€Œè¿™é‡Œå‘ç”Ÿçš„å…¶å®æ˜¯å¯¹lambå¯¹è±¡çš„ä¸€ä¸ªæ‹·è´ï¼›

std::function å¯¹è±¡åœ¨è¯­ä¹‰ä¸Šæ˜¯å€¼ç±»å‹`value semantics`ï¼›ä¸`intï¼Œ struct`ä¸€æ ·ï¼›å°†ä¸€ä¸ªå‡½æ•°å¯¹è±¡èµ‹å€¼ç»™å¦ä¸€ä¸ªå¯¹è±¡ï¼Œæ˜¯å®Œå®Œå…¨å…¨çš„copyï¼Œ

ä¸‹é¢æ˜¯å¯¹C++11 specçš„ä¸€ä¸ªè§£æåŸæ–‡
> When the C++ compiler encounters a lambda expression, it generates a new anonymous class. Each captured variable becomes a member of that anonymous class, and the member is initialized from the variable in the outer scope. Finally, the anonymous class is given an operator() implementation whose parameter list is the parameter list of the lambda, whose body is the lambda body, and whose return value is the lambda return value.

æˆ‘ä»¬å¯ä»¥çœ‹è¿™æ ·ä¸€ä¸ªä¾‹å­æ¥è¯´æ˜è¿™ä¸ªé—®é¢˜ï¼š

```cpp
void A::SomeMethod() {
 int i = 0, j = 1;
 auto f = [this, i, &j](int k) -> int
    { return this->calc(i + j + k); };
 ...
}
//The compiler internally converts this to something like this:

void A::SomeMethod() {
 int i = 0, j = 1;

 // Autogenerated by the compiler
 class AnonymousClass$0 {
 public:
  AnonymousClass$0(A* this$, int i$, int& j$) :
   this$0(this$), i$0(i$), j$0(j$) { }
  int operator(int k) const
     { return this$0->calc(i$0 + j$0 + k); }
 private:
  A* this$0;			// this captured by value
  int i$0;                 // i captured by value
  int& j$0;                // j captured by reference
 };

 auto f = AnonymousClass$0(this, i, j);
 ...
}
```

ä¸Šé¢è¯´åˆ°çš„å½“æ²¡æœ‰æ•è·åˆ—è¡¨æ—¶ï¼Œ lambdaè¡¨è¾¾å¼å¯¹è±¡å¯ä»¥èµ‹å€¼ç»™ä¸€ä¸ªå‡½æ•°å¯¹è±¡ï¼›æ®è¯´åœ¨C++11çš„specä¸­å¹¶æ²¡æœ‰æ˜ç¡®ï¼Œ æ‰€ä»¥å…·ä½“å®ç°çœ‹å…·ä½“ç¼–è¯‘å™¨å’Œå¹³å°çš„æ”¯æŒï¼›å…·ä½“æœ‰ç²¾åŠ›å¯ä»¥å»æŸ¥æŸ¥specæ–‡æ¡£ï¼› è€Œè¿™ç§ç­‰æ•ˆï¼Œ åœ¨lambdaå¯¹è±¡å†…éƒ¨å®ç°å…¶äº‹æˆ‘ä»¬å¾ˆå®¹æ˜“çš„å°±æƒ³åˆ°åªè¦åœ¨åŒ¿åç±»ä¸­å¦‚æœåšä¸€ä¸ªè½¬æ¢å°±å¯ä»¥ï¼›æ¯”å¦‚è¯´ï¼š
```cpp
 class AnonymousClass$0
 {
 public:
  AnonymousClass$0()  { }
  operator int (__cdecl *)(int k) { return cdecl_static_function; }
  operator int (__stdcall *)(int k) { return stdcall_static_function; }
  operator int (__fastcall *)(int k) { return fastcall_static_function; }
  int operator(int k) { return cdecl_static_function(k); }
 private:
  static int __cdecl cdecl_static_function(int k) { return calc(k + 42); }
  static int __stdcall stdcall_static_function(int k) { return calc(k + 42); }
  static int __fastcall fastcall_static_function(int k) { return calc(k + 42); }
 };

 auto f = AnonymousClass$0();
```

é™·é˜±
---

é™·é˜±å¾€å¾€æ¥è‡ªäºæˆ‘ä»¬è‡ªå·±çš„é”™è¯¯ğŸ˜Šï¼ è™½ç„¶çœ‹ç€åˆ°å¤„éƒ½åœ¨è¯´ä»€ä¹ˆä»»ä½•è¯­è¨€éƒ½`å›¾çµç­‰ä»·`, å½“æ—¶è¯­è¨€å„æœ‰åƒç§‹ï¼Œæˆ‘ä»¬ä¸æ˜¯è¯­è¨€çš„è®¾è®¡è€…ï¼Œ éš¾å…åœ¨ä¸ç²¾é€šçš„æ—¶å€™æ‰è¿›é™·é˜±é‡Œï¼›å› ä¸ºcppæ²¡æœ‰gcæœºåˆ¶ï¼Œä¹Ÿæ²¡æœ‰swiftä¸­ï½€weakï¼Œunownerï½€è¿™ç§é»˜è®¤çš„å®ç°ï¼Œ æ‰€ä»¥ï¼Œå¦‚æœä½ åœ¨ç”¨lambdaè¡¨è¾¾å¼çš„æ—¶å€™ï¼›**å½“ä¼ å…¥çš„æ˜¯æŒ‡é’ˆæˆ–è€…å¼•ç”¨æ—¶ï¼Œè¯·ä¸€å®šä¸€å®šè¦ç¡®ä¿lambdaè¡¨è¾¾å¼çš„å‡½æ•°ä½“æ‰§è¡Œçš„æ—¶å€™ï¼Œå¼•ç”¨æ•è·çš„å€¼æ²¡æœ‰è¢«ææ„ï¼ï¼ï¼** ä¸ç„¶ä½ ä¸€å®šèººæªçš„;

reference:
---

- [lambda expressions](http://www.stroustrup.com/N1968-lambda-expressions.pdf)
- [demystifying-c-lambdas](https://blog.feabhas.com/2014/03/demystifying-c-lambdas/)



